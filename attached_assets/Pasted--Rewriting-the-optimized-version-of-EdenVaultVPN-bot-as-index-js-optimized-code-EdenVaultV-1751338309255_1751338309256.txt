# Rewriting the optimized version of EdenVaultVPN bot as index.js
optimized_code = """
// EdenVaultVPN Bot - Optimized for VPS Deployment

require('dotenv').config();
const TelegramBot = require('node-telegram-bot-api');
const QRCode = require('qrcode');
const axios = require('axios');
const fs = require('fs');
const { v4: uuidv4 } = require('uuid');

// === ENV ===
const BOT_TOKEN = process.env.BOT_TOKEN;
const ADMIN_ID = process.env.ADMIN_ID;
const OUTLINE = {
    us: 'https://154.53.57.223:32987/W6Si53JA7hsJXZqMLsztAg',
    sg: 'https://154.26.138.68:7127/h6bsFmcBWyN8O_0i6BBJiw'
};

if (!BOT_TOKEN || !ADMIN_ID) {
    console.error('Missing BOT_TOKEN or ADMIN_ID in .env');
    process.exit(1);
}

const bot = new TelegramBot(BOT_TOKEN, { polling: true });

// === Plans ===
const plans = {
    mini: { name: 'Mini Vault', gb: 100, price: 3000, days: 30 },
    power: { name: 'Power Vault', gb: 300, price: 6000, days: 30 },
    ultra: { name: 'Ultra Vault', gb: 500, price: 8000, days: 30 }
};

// === Users ===
const userState = new Map();
const pendingProofs = new Map();

// === Commands ===
bot.onText(/\\/start/, (msg) => {
    const id = msg.chat.id;
    bot.sendMessage(id, '📦 Choose your VPN Plan:', {
        reply_markup: {
            inline_keyboard: [
                [{ text: 'Mini (100GB) - 3000MMK', callback_data: 'plan_mini' }],
                [{ text: 'Power (300GB) - 6000MMK', callback_data: 'plan_power' }],
                [{ text: 'Ultra (500GB) - 8000MMK', callback_data: 'plan_ultra' }]
            ]
        }
    });
});

bot.on('callback_query', async (query) => {
    const id = query.message.chat.id;
    const data = query.data;

    if (data.startsWith('plan_')) {
        const key = data.split('_')[1];
        userState.set(id, { plan: key });
        bot.sendMessage(id, '🌍 Choose Server:', {
            reply_markup: {
                inline_keyboard: [
                    [{ text: '🇺🇸 US Server', callback_data: `srv_us_${key}` }],
                    [{ text: '🇸🇬 SG Server', callback_data: `srv_sg_${key}` }],
                    [{ text: '🌐 Both', callback_data: `srv_both_${key}` }]
                ]
            }
        });
    }

    if (data.startsWith('srv_')) {
        const [, server, planKey] = data.split('_');
        const plan = plans[planKey];
        const uid = uuidv4();
        pendingProofs.set(uid, { id, server, planKey });

        bot.sendMessage(id, `💳 Pay ${plan.price} MMK via KPay to 09123456789\nThen upload screenshot.`, {
            reply_markup: {
                inline_keyboard: [
                    [{ text: '📤 Upload Payment Proof', callback_data: `proof_${uid}` }]
                ]
            }
        });
    }

    if (data.startsWith('proof_')) {
        const uid = data.split('_')[1];
        bot.sendMessage(id, '📸 Please send your payment screenshot now.');
        bot.once('photo', async (photoMsg) => {
            bot.sendMessage(id, '✅ Received. Waiting for admin approval.');

            const adminText = `🧾 New Payment:\nUser: ${id}\nPlan: ${pendingProofs.get(uid).planKey}\nServer: ${pendingProofs.get(uid).server}\nID: ${uid}`;
            bot.forwardMessage(ADMIN_ID, id, photoMsg.message_id);
            bot.sendMessage(ADMIN_ID, adminText, {
                reply_markup: {
                    inline_keyboard: [
                        [{ text: '✅ Approve', callback_data: `approve_${uid}` }],
                        [{ text: '❌ Reject', callback_data: `reject_${uid}` }]
                    ]
                }
            });
        });
    }

    if (data.startsWith('approve_')) {
        const uid = data.split('_')[1];
        const proof = pendingProofs.get(uid);
        if (!proof) return;

        const user = proof.id;
        const plan = plans[proof.planKey];
        const split = proof.server === 'both';
        const limit = (plan.gb / (split ? 2 : 1)) * 1024 ** 3;
        const keys = [];

        async function create(server) {
            const r = await axios.post(`${OUTLINE[server]}/access-keys`, {
                name: `VPN_${user}_${server}`
            }, { httpsAgent: new (require('https').Agent)({ rejectUnauthorized: false }) });
            await axios.put(`${OUTLINE[server]}/access-keys/${r.data.id}/data-limit`, {
                limit: { bytes: limit }
            }, { httpsAgent: new (require('https').Agent)({ rejectUnauthorized: false }) });
            return r.data.accessUrl;
        }

        if (split) {
            keys.push(await create('us'));
            keys.push(await create('sg'));
        } else {
            keys.push(await create(proof.server));
        }

        bot.sendMessage(user, '🎉 Payment Approved!\nHere are your VPN keys:');
        for (const key of keys) {
            bot.sendMessage(user, key);
            const qr = await QRCode.toBuffer(key);
            bot.sendPhoto(user, qr);
        }

        pendingProofs.delete(uid);
        bot.sendMessage(id, '✅ Approved & sent to user.');
    }

    if (data.startsWith('reject_')) {
        const uid = data.split('_')[1];
        const proof = pendingProofs.get(uid);
        if (!proof) return;

        bot.sendMessage(proof.id, '❌ Payment rejected. Please contact support.');
        pendingProofs.delete(uid);
        bot.sendMessage(id, '🚫 Rejected.');
    }

    bot.answerCallbackQuery(query.id);
});
"""

# Save the optimized code to index.js for user download
with open("/mnt/data/index.js", "w") as f:
    f.write(optimized_code.strip())

"/mnt/data/index.js"
